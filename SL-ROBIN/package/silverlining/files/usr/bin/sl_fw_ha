#!/usr/bin/microperl

# this program copyright 2009 Silver Lining Networks Inc., and is governed
# by the Silver Lining software license, see http://www.silverliningnetworks.com/
# if you have not received a copy of the license with this software, please
# email support@silverliningnetworks.com for a copy

our $DEBUG       = 0;
our $CONFIG_FILE = '/etc/sl/sl.conf';
our $ATTEMPTS    = 0;
our $UCI         = '/bin/uci';
our $MD5         = '/usr/bin/md5sum';
our $RMMOD       = '/sbin/rmmod';
our $INSMOD      = '/sbin/insmod';
our $LSMOD       = '/sbin/lsmod';
our $IPTABLES    = '/usr/sbin/iptables';
our $VERSION     = '022';
our $SLEEP       = 300;
our $LIMIT       = 10000;
$|++;

# figure out if we are a gateway or repeater
my $role = `$UCI get node.general.role`;
my $type = ( $role == 1 ) ? 'gateway' : 'client';

# based on that, figure out what interface to route traffic through
my $int = ( $role == 1 ) ? 'ath1' : 'br-lan';

my $d = shift;

# grab the mac address
my $board = `$UCI get node.general.board`;

my $macaddr;
if ( $board eq 'UBNT' ) {

    $macaddr = `$UCI get node.general.wlanMAC`;

}
else {

    $macaddr = `$UCI get node.general.myMAC`;
}

print "Board isi $board, Macaddr is $macaddr\n" if $DEBUG;

####################################################
# no config is fa non starter
my $config_proxy = get_config_proxy($CONFIG_FILE);

unless ($config_proxy) {

    print STDERR "no sln config_proxy exists\n";
    exit(1);
}

print "Using proxy $config_proxy\n" if $DEBUG;

# ping the proxy
if ( my $slug = ping_ok( $config_proxy, $macaddr ) ) {

    print "ping was ok, sln state on\n" if $DEBUG;

    if ( $ct =~ m/Ad Serving On/ ) {
        start_sln( $config_proxy, $macaddr );
    } elsif ($ct =~ m/Ad Serving Off/ ) {
        stop_sln( $config_proxy, $macaddr );
    }
   
    # custom skips refresh
    if ( my ($skips) = $ct =~ m/CustomSkips\s(http\w+)/) {

        my $get = `wget -O /etc/sl/custom_skips.txt $skips`;
        print "custom_skips refetched, $get" if $DEBUG;

        # hup the service
        stop_sln;
        sleep 1;
        start_sln;
    }

    exit(0);

}
else {

    print STDERR "No available proxies, disabling silver lining\n";
    stop_sln($config_proxy);
    exit(1);
}

sub get_config_proxy {
    my $config_file = shift;
    my $fh;
    unless ( -e $config_file ) {
        restore_config_file();
    }
    open( $fh, '<', $config_file ) or die $!;
    my $line_count = 0;
    while (<$fh>) {
        $line_count++;
        next unless $_ =~ m/^proxy/;
        $config_proxy = ( split( /\s+/, $_ ) )[1];
    }
    close($fh) or die $!;
    if ( $line_count == 0 ) {
        my $restored = restore_config_file();
        unless ($restored) {
            print STDERR "could not restore config file, exiting\n";
            return;
        }

        $config_proxy = get_config_proxy($config_file);
        unless ($config_proxy) {
            print STDERR "could not get config proxy, fatal error`\n";
            return;
        }
        elsif ($config_proxy) {
            print "retrieved config_proxy from restored default\n" if $DEBUG;
        }
    }
    unless ($config_proxy) {
        print STDERR "config file contains data but no config_proxy\n";
        return;
    }
    print "got config_proxy $config_proxy\n" if $DEBUG;
    return $config_proxy;

}

sub restore_config_file {

    if ( $ATTEMPTS++ == 1 ) {
        print STDERR "failed to restore_config_file, exiting\n";
        return;
    }

    # config file got truncated somehow
    my $file = 'sl.conf';
    my $url  = "http://fw.slwifi.com/conf/$file";
    chdir('/tmp');
    unlink($file) if -e $file;
    print "grabbing url $url\n" if $DEBUG;
    my $grab = `/usr/bin/wget $url`;
    unless ( -e $file ) {
        print STDERR "grab failed!: $grab\n";

        # not much we can do without a config file
        return;
    }

    my $mv = `mv $file $CONFIG_FILE`;
    return 1;
}

sub stop_sln {
    my $proxy = shift;

    return unless _check_sln();

    print "sln active, de-activating\n" if $DEBUG;

    my $teardown = _teardown_sln($proxy);

    print "teardown sln $teardown\n" if $DEBUG;

    # remove kernel modules
    `rmmod nf_nat_sl`;
    `rmmod nf_conntrack_sl`;

    return 1;
}

sub start_sln {
    my ( $proxy, $macaddr ) = @_;

    # see if sln is active
    return 1 if _check_sln();

    print "sln inactive, activating\n" if $DEBUG;

    # first make sure the base nodogsplash rules are in effect
    return unless _nodog_active();

    # load the kernel modules
    $macaddr =~ s/\://g;
    $macaddr = lc($macaddr);
    my $load_cmd = "$INSMOD nf_nat_sl sl_device=$macaddr sl_proxy=$proxy";
    `$INSMOD nf_conntrack_sl`;
    `$load_cmd`;

    my $base_setup  = _setup_sln_base($proxy);
    my $skips_setup = _setup_sln_skips($proxy);
    print "base_setup $base_setup, skips setup $skips_setup\n" if $DEBUG;

    return 1;
}

sub _nodog_active {

    return grep { /^ndsOUT/ } (`iptables -t nat -n -L`);
}

# checks to see if sln firewall enabled
sub _check_sln {

    # cheap way, look for the target
    my $sln_is_active = grep { /^ndsSLN/ } (`iptables -t nat -n -L`);

    print "sln is active? $sln_is_active\n" if $DEBUG;

    return $sln_is_active;
}

# sets up the base firewall rules
sub _setup_sln_base {
    my $proxy = shift;

    my $base = <<BASE;
$IPTABLES -t nat -N ndsSLN
$IPTABLES -t nat -I ndsSLN 1 -i $int -p tcp -m tcp --dport 8135 -j DNAT --to :80
$IPTABLES -t nat -I ndsSLN 2 -i $int -p tcp -m tcp --dport 80 -j DNAT --to-destination $proxy
$IPTABLES -t nat -I ndsSLN 3 -j ACCEPT
$IPTABLES -t nat -D ndsOUT -m mark --mark 0x100 -j ACCEPT
$IPTABLES -t nat -I ndsOUT -m mark --mark 0x100 -j ndsSLN
BASE

    foreach my $rule ( split( "\n", $base ) ) {
        `$rule`;
    }

    return 1;
}

sub _teardown_sln {
    my $proxy = shift;

    my $base = <<BASE;
$IPTABLES -t nat -D ndsOUT -m mark --mark 0x100 -j ndsSLN
$IPTABLES -t nat -I ndsOUT -m mark --mark 0x100 -j ACCEPT
$IPTABLES -t nat -F ndsSLN
$IPTABLES -t nat -X ndsSLN
BASE

    foreach my $rule ( split( "\n", $base ) ) {
        `$rule`;
    }

    return 1;
}

sub _setup_sln_skips {

    my $fh;
    open( $fh, '<', '/etc/sl/skips.txt' );
    while ( my $line = <$fh> ) {
        chomp($line);
        `$IPTABLES -t nat -I ndsSLN 2 --dst $line -m tcp -p tcp -j ACCEPT`;
    }
    close($fh);

    # local hosts added by user
    if ( -e '/etc/sl/custom_skips.txt' ) {

        open( $fh, '<', '/etc/sl/custom_skips.txt' );
        while ( my $line = <$fh> ) {
            chomp($line);
            `$IPTABLES -t nat -I ndsSLN 2 --dst $line -m tcp -p tcp -j ACCEPT`;
        }
        close($fh);
    }

    return 1;
}

sub ping_ok {
    my ( $proxy, $macaddr ) = @_;

    # escape the macaddress
    my $escaped = $macaddr;
    $escaped =~ s/:/%3A/g;

    my $slug = "$macaddr\_$VERSION";
    my $loc  = "http://$proxy/sl_secret_ping_button/$slug";
    my $cmd  = "wget $loc  2>&1";
    print "Making request $cmd\n" if $DEBUG;
    my $ping = `$cmd`;
    print "ping result: _$ping\_\n"  if $DEBUG;
    print "looking for file $slug\n" if $DEBUG;
    if (   ( !-e $slug )
        or ( $ping eq '' )
        or ( $ping =~ m/error 50/i )
        or ( $ping =~ m/connection refused/i )
        or ( $ping =~ m/error/i )
        or ( $ping =~ m/unable to connect/i )
        or ( $ping =~ m/no response from server/i ) )
    {

        print STDERR "Proxy $proxy returned ping error:\n  $ping\n";
        return;

    }
    elsif ( -e $slug ) {

        print "ping ok, file $macaddr exists\n" if $DEBUG;

        my $fh;
        open( $fh, '<', $slug ) or die $!;
        my $ct = do { local $/; <$fh> };
        close($fh) or die $!;

        unlink($slug) or print STDERR "could not remove ping file $slug\n";

        chomp($ct);
        print("slug package is $ct\n") if $DEBUG;
        if ( length($ct) > 0 ) {

            print "Ping returned ok: $ping\n" if $DEBUG;
            return $ct;

        }
        else {

            print("slug missing, stop energizers\n") if $DEBUG;
            return;
        }
    }
}

