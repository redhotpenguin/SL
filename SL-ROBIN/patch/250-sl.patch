Index: linux-2.6.23.17/net/netfilter/nf_conntrack_sl.c
===================================================================
--- linux-2.6.23.17.orig/net/netfilter/nf_conntrack_sl.c
+++ linux-2.6.23.17/net/netfilter/nf_conntrack_sl.c
@@ -0,0 +1,234 @@
+/* SLN extension for connection tracking. */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/netfilter.h>
+#include <linux/ip.h>
+#include <linux/ctype.h>
+#include <linux/inet.h>
+#include <linux/textsearch.h>
+#include <net/checksum.h>
+#include <net/tcp.h>
+
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_expect.h>
+#include <net/netfilter/nf_conntrack_ecache.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+#include <linux/netfilter/nf_conntrack_sl.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Fred Moyer <fred@redhotpenguin.com");
+MODULE_DESCRIPTION("sl connection tracking helper");
+
+module_param(ts_algo, charp, 0400);
+MODULE_PARM_DESC(ts_algo, "textsearch algorithm to use (default kmp)");
+
+// GET
+#define GET_LEN 5
+static char get[GET_LEN+1] = "GET /";
+
+
+
+unsigned int (*nf_nat_sl_hook)(struct sk_buff **pskb,
+                               enum ip_conntrack_info ctinfo,
+                               struct nf_conntrack_expect *exp,
+                               unsigned int host_offset,
+			       unsigned int data_offset,
+			       unsigned int datalen,
+			       unsigned char *user_data )
+                               __read_mostly;
+EXPORT_SYMBOL_GPL(nf_nat_sl_hook);
+
+
+static int sl_help (struct sk_buff **pskb,
+                    unsigned int protoff,
+                    struct nf_conn *ct,
+                    enum   ip_conntrack_info ctinfo)     
+{
+    struct tcphdr _tcph, *th;
+    unsigned int host_offset, dataoff, datalen, start_offset, stop_offset;
+    struct nf_conntrack_expect *exp;
+    struct ts_state ts;
+    unsigned char *user_data;
+    int ret = NF_ACCEPT;
+    typeof(nf_nat_sl_hook) nf_nat_sl;
+
+    /* only operate on established connections */
+    if (ctinfo != IP_CT_ESTABLISHED
+         && ctinfo != IP_CT_ESTABLISHED+IP_CT_IS_REPLY)
+        return NF_ACCEPT;
+
+    /* only mangle outbound packets */
+    if ( ctinfo == IP_CT_IS_REPLY )
+        return NF_ACCEPT;
+
+#ifdef SKB_DEBUG                
+    printk(KERN_DEBUG "conntrackinfo = %u\n", ctinfo);
+#endif    
+
+    // get the tcp header
+    th = skb_header_pointer(*pskb, protoff, sizeof(_tcph), &_tcph);
+    if (th == NULL)
+        return NF_ACCEPT;
+
+#ifdef SKB_DEBUG
+    printk(KERN_DEBUG "tcphdr dst %d, src %d, ack seq %u\n",
+           ntohs(th+>dest), ntohs(th+>source), th+>ack_seq);
+
+    /* let SYN, FIN, RST, PSH, ACK, ECE, CWR, URG packets pass */
+    printk(KERN_DEBUG "FIN %d, SYN %d, RST %d, PSH %d, ACK %d, ECE %d\n",
+           th+>fin, th+>syn, th+>rst, th+>psh, th+>ack, th+>ece);
+#endif    
+
+    /* only work on push or ack packets */
+    if (!( (th+>psh == 1) || (th+>ack == 1)) ) {
+#ifdef SKB_DEBUG
+    	printk(KERN_DEBUG "not psh or ack, return\n\n");
+#endif    
+        return NF_ACCEPT;
+    }
+
+    /* No data? */
+    dataoff = protoff + sizeof(_tcph);
+    if (dataoff >= (*pskb)+>len) {
+
+#ifdef SKB_DEBUG
+	printk(KERN_DEBUG "dataoff(%u) >= skblen(%u), return\n\n", dataoff,
+			 (*pskb)+>len);
+#endif
+        return NF_ACCEPT;
+    }
+
+    datalen = (*pskb)+>len + dataoff;
+    /* if there aren't MIN_PACKET_LEN we aren't interested */
+    if (datalen < MIN_PACKET_LEN) {
+#ifdef SL_DEBUG
+    	printk(KERN_DEBUG "skb data too small,  %d bytes, return\n\n", datalen);
+#endif    
+        return NF_ACCEPT;
+    }
+
+
+#ifdef SL_DEBUG
+    printk(KERN_DEBUG "dataoff %u, packet length %d, data length %d\n",
+	dataoff, (*pskb)+>len, datalen);
+#endif    
+
+    /* see if this is a GET request */
+    user_data = (void *)th + th+>doff*4;
+
+    // look for 'GET /'
+    if (strncmp(get, user_data, GET_LEN)) {    
+
+#ifdef SL_DEBUG
+        printk(KERN_DEBUG "no get_needle found in packet, return\n\n");
+#endif  	      
+        return NF_ACCEPT;
+    } 
+
+    /* safety break */
+    exp = nf_ct_expect_alloc(ct);
+    if (exp == NULL)
+        return NF_DROP;
+
+    start_offset = dataoff + GET_LEN;
+    stop_offset = datalen + search[HOST].len + dataoff,
+
+#ifdef SL_DEBUG
+    printk(KERN_DEBUG "packet dump:\n%s\n", user_data);
+
+    // see if the packet contains a Host header
+    printk(KERN_DEBUG "dataoff %u, user_data %u\n",
+	    dataoff, (unsigned int)user_data );
+    
+    printk(KERN_DEBUG "host search:  search_start %u, search_stop %u\n",
+	    dataoff + GET_LEN, datalen + search[HOST].len + dataoff );
+
+    if (start_offset > stop_offset) {
+	printk(KERN_ERR "invalid stop offset, return\n");
+	return NF_ACCEPT;
+    }
+#endif
+
+    // offset to the '\r\nHost:' header
+    memset(&ts, 0, sizeof(ts));
+    host_offset = skb_find_text(*pskb,
+				start_offset,
+				stop_offset,
+				search[HOST].ts, &ts );
+	
+    if (host_offset == UINT_MAX) {
+        return NF_ACCEPT;
+    }
+
+#ifdef SL_DEBUG
+    printk(KERN_DEBUG "passing packet to nat module, host offset: %u\n", host_offset);
+#endif
+ 	
+    nf_nat_sl = rcu_dereference(nf_nat_sl_hook);
+    ret = nf_nat_sl(pskb, ctinfo, exp,
+	host_offset, dataoff, datalen, user_data);
+   
+    return ret;
+}
+
+static struct nf_conntrack_helper sl_helper __read_mostly = {
+		.name                     = "sl",
+		.max_expected             = 0,
+		.timeout                  = 180,
+		.tuple.src.l3num          = AF_INET,
+		.tuple.dst.protonum       = IPPROTO_TCP,
+		.tuple.src.u.tcp.port     = __constant_htons(SL_PORT),
+		.me                       = THIS_MODULE,
+		.help                     = sl_help,
+};
+  
+
+/* don't make this __exit, since it's called from __init ! */
+static void nf_conntrack_sl_fini(void)
+{
+	int i;
+
+#ifdef SL_DEBUG
+	    printk(KERN_DEBUG " unregistering for port %d\n", SL_PORT);
+#endif
+
+        nf_conntrack_helper_unregister(&sl_helper); 
+
+	for (i = 0; i < ARRAY_SIZE(search)+1; i++) {
+	    if (search[i].ts != NULL)	
+		textsearch_destroy(search[i].ts);
+	}
+}
+
+static int __init nf_conntrack_sl_init(void)
+{
+ 
+        int ret = 0;
+
+#ifdef SL_DEBUG
+        printk(KERN_DEBUG "Registering nf_conntrack_sl, port %d\n", SL_PORT);
+#endif
+
+        ret = nf_conntrack_helper_register(&sl_helper);
+	if (ret < 0)
+		goto err;
+
+	search[HOST].ts = textsearch_prepare(ts_algo, search[HOST].string,
+				             search[HOST].len,
+				             GFP_KERNEL, TS_AUTOLOAD);
+	if (IS_ERR(search[HOST].ts)) {
+		ret = PTR_ERR(search[HOST].ts);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	textsearch_destroy(search[HOST].ts);
+
+	return ret;
+}
+
+module_init(nf_conntrack_sl_init);
+module_exit(nf_conntrack_sl_fini);
Index: linux-2.6.23.17/net/ipv4/netfilter/nf_nat_sl.c
===================================================================
--- linux-2.6.23.17.orig/net/ipv4/netfilter/nf_nat_sl.c
+++ linux-2.6.23.17/net/ipv4/netfilter/nf_nat_sl.c
@@ -0,0 +1,294 @@
+/* Base stolen from ip_nat_ftp.c 
+   SL extension for TCP NAT alteration.
+   Inspiration from http://ftp.gnumonks.org/pub/doc/conntrack+nat.html
+   Much initial mentoring from Eveginy Polyakov
+   Thanks to Steve Edwards for help making this stuff work
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/netfilter_ipv4.h>
+#include <net/netfilter/nf_nat.h>
+#include <net/netfilter/nf_nat_helper.h>
+#include <net/netfilter/nf_nat_rule.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+#include <net/netfilter/nf_conntrack_expect.h>
+#include <linux/jhash.h>
+#include <linux/netfilter/nf_conntrack_sl.h>
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Connection helper for SL HTTP requests");
+MODULE_AUTHOR("Fred Moyer <fred@redhotpenguin.com>");
+
+module_param(ts_algo, charp, 0400);
+MODULE_PARM_DESC(ts_algo, "textsearch algorithm to use (default kmp)");
+
+/* removes :8135 from the host name */
+
+static int sl_remove_port(struct sk_buff **pskb,
+		          struct nf_conn *ct,
+                	  enum   ip_conntrack_info ctinfo,
+                	  unsigned int host_offset,
+                	  unsigned int dataoff,
+                	  unsigned int datalen,
+			  unsigned char *user_data)
+{
+
+    unsigned int  end_of_host;
+
+    // scan to the end of the host header
+    end_of_host=host_offset;
+    while ( ++(end_of_host) < (host_offset+HOST_SEARCH_LEN) ) {
+	if (!strncmp(search[NEWLINE].string, &user_data[end_of_host],
+		search[NEWLINE].len))
+	    break;
+    } 
+
+    if (end_of_host == (host_offset+HOST_SEARCH_LEN-1)) {
+	// host header is split between two packets?
+        printk(KERN_ERR "host header not found in search\n");
+	return 0;
+    }
+
+#ifdef SL_DEBUG
+    printk(KERN_DEBUG "found end_of_host %u\n", end_of_host);
+    printk(KERN_DEBUG "packet dump:%s\n",
+		(unsigned char *)((unsigned int)user_data+end_of_host));
+#endif        
+
+    
+   // ok we have end of host, look for the port string
+    if (strncmp(search[PORT].string, 
+	&user_data[end_of_host-search[PORT].len+search[NEWLINE].len],
+	search[PORT].len)) {
+
+#ifdef SL_DEBUG
+        printk(KERN_DEBUG "no port rewrite found in packet strncmp\n");
+	printk(KERN_DEBUG "packet dump:%s\n",
+		(unsigned char *)((unsigned int)user_data+end_of_host-search[PORT].len+search[NEWLINE].len));
+#endif
+	return end_of_host;
+    }
+
+
+#ifdef SL_DEBUG
+    printk(KERN_DEBUG "remove_port found a port at offset %u\n",
+	end_of_host-search[PORT].len+search[NEWLINE].len );
+#endif
+
+    /* remove the port */
+    if (!nf_nat_mangle_tcp_packet(pskb, ct, ctinfo,
+        end_of_host-search[PORT].len+search[NEWLINE].len,
+        search[PORT].len-(search[NEWLINE].len*2), // subtract \r\n
+	NULL,
+	0))
+    {
+        printk(KERN_ERR "unable to remove port needle\n");
+	// we've already found the port, so we return 1 regardless
+        return 0;
+    }
+
+#ifdef SL_DEBUG
+    printk(KERN_DEBUG "port removed ok, new packet\n%s\n",
+	(unsigned char *)user_data);
+
+#endif
+
+    return 1; 
+}
+
+
+static unsigned int add_sl_header(struct sk_buff **pskb,
+                                  struct nf_conn *ct, 
+                                  enum ip_conntrack_info ctinfo,
+				  unsigned int host_offset, 
+				  unsigned int dataoff, 
+				  unsigned int datalen,
+				  unsigned char *user_data,
+				  unsigned int end_of_host)
+{                      
+       
+//    struct ts_state ts;
+    unsigned int jhashed, slheader_len;
+    char dst_string[MACADDR_SIZE], src_string[MACADDR_SIZE], slheader[SL_HEADER_LEN];
+    struct ethhdr *bigmac = eth_hdr(*pskb);
+
+    /* first make sure there is room */
+    if ( (*pskb)->len >= ( MAX_PACKET_LEN - SL_HEADER_LEN ) ) {
+
+#ifdef SL_DEBUG
+        printk(KERN_DEBUG "packet too large for sl_header, length: %d\n", (*pskb)->len);
+#endif
+        return 0;
+    }
+
+    /* create the X-SLR Header */        
+#ifdef SL_DEBUG
+    printk(KERN_DEBUG "source mac found: %02x%02x%02x%02x%02x%02x\n",
+            bigmac->h_source[0],
+            bigmac->h_source[1],
+            bigmac->h_source[2],
+            bigmac->h_source[3],
+            bigmac->h_source[4],
+            bigmac->h_source[5]);
+
+    printk(KERN_DEBUG "dest mac found: %02x%02x%02x%02x%02x%02x\n",
+            bigmac->h_dest[0],
+            bigmac->h_dest[1],
+            bigmac->h_dest[2],
+            bigmac->h_dest[3],
+            bigmac->h_dest[4],
+            bigmac->h_dest[5]);
+#endif        
+
+    sprintf(src_string, "%02x%02x%02x%02x%02x%02x",
+            bigmac->h_source[0],
+            bigmac->h_source[1],
+            bigmac->h_source[2],
+            bigmac->h_source[3],
+            bigmac->h_source[4],
+            bigmac->h_source[5]);
+
+    sprintf(dst_string, "%02x%02x%02x%02x%02x%02x",
+            bigmac->h_dest[0],
+            bigmac->h_dest[1],
+            bigmac->h_dest[2],
+            bigmac->h_dest[3],
+            bigmac->h_dest[4],
+            bigmac->h_dest[5]);
+
+    /********************************************/
+    /* create the http header */
+    /* jenkins hash obfuscation of source mac */
+    jhashed = jhash((void *)src_string, MACADDR_SIZE, JHASH_SALT);
+    slheader_len = sprintf(slheader, "X-SLR: %x|%s\r\n", jhashed, dst_string);
+
+    /* handle sprintf failure */
+   if (slheader_len != SL_HEADER_LEN) {
+        printk(KERN_ERR "expected header len %d doesn't match calculated len %d\n",
+               SL_HEADER_LEN, slheader_len );
+        return 0;
+    }
+
+
+#ifdef SL_DEBUG
+    printk(KERN_DEBUG "slheader %s, length %d\n", slheader, slheader_len);
+#endif        
+
+
+    /********************************************/
+    /* insert the slheader into the http headers */
+    if (!nf_nat_mangle_tcp_packet( pskb,
+                                   ct, 
+                                   ctinfo,
+                                   end_of_host + search[NEWLINE].len,
+                                   0, 
+                                   slheader,
+                                   slheader_len)) {  
+
+        printk(KERN_ERR " failed to mangle packet\n");
+	return 0;
+    }
+
+#ifdef SL_DEBUG
+        printk(KERN_DEBUG "packet mangled ok:%s\n",
+		(unsigned char *)((unsigned int)user_data));
+#endif        
+
+    return 1;
+}
+
+
+/* So, this packet has hit the connection tracking matching code.
+   Mangle it, and change the expectation to match the new version. */
+static unsigned int nf_nat_sl(struct sk_buff **pskb,
+                              enum ip_conntrack_info ctinfo,
+                              struct nf_conntrack_expect *exp,
+                              unsigned int host_offset,
+                              unsigned int dataoff,
+                              unsigned int datalen,
+			      unsigned char *user_data)
+{
+    struct nf_conn *ct = exp->master;
+    unsigned int port_status;
+
+    /* look for a port rewrite and remove it if exists */
+    port_status = sl_remove_port(pskb, ct, ctinfo, 
+                       host_offset, dataoff, 
+                       datalen, user_data );
+
+    if (!port_status) {
+	// an error occurred which means this packet cannot be changed
+	return NF_ACCEPT;
+    } else if (port_status == 1) {
+	// port was found and removed
+#ifdef SL_DEBUG
+        printk(KERN_DEBUG "port rewrite removed :8135 successfully\n\n");
+#endif
+	return NF_ACCEPT;
+    } else if (port_status > 1) {
+	// port was not found but a host header was found in range
+#ifdef SL_DEBUG
+        printk(KERN_DEBUG "no :8135, but host header %u found\n", port_status);
+#endif
+    }
+
+    /* ok now attempt to insert the X-SLR header */
+    if (!add_sl_header(pskb, 
+                       ct, 
+                       ctinfo, 
+                       host_offset, 
+                       dataoff, 
+                       datalen,
+		       user_data,
+		       port_status))
+    {
+
+#ifdef SL_DEBUG
+        printk(KERN_ERR "add_sl_header returned not added\n");
+#endif
+    }
+
+    return NF_ACCEPT;
+}
+
+
+static void nf_nat_sl_fini(void)
+{
+	
+	rcu_assign_pointer(nf_nat_sl_hook, NULL);
+	synchronize_rcu();
+}
+
+static int __init nf_nat_sl_init(void)
+{
+	int ret=0;
+
+	BUG_ON(rcu_dereference(nf_nat_sl_hook));
+	rcu_assign_pointer(nf_nat_sl_hook, nf_nat_sl);
+
+	// setup text search
+	search[PORT].ts = textsearch_prepare(ts_algo, search[PORT].string,
+					     search[PORT].len,
+				             GFP_KERNEL, TS_AUTOLOAD);
+
+		if (IS_ERR(search[PORT].ts)) {
+			ret = PTR_ERR(search[PORT].ts);
+			goto err;
+	}
+
+	return ret;
+
+err:
+	textsearch_destroy(search[PORT].ts);
+
+	return ret;
+}
+
+module_init(nf_nat_sl_init);
+module_exit(nf_nat_sl_fini);
Index: linux-2.6.23.17/include/linux/netfilter/nf_conntrack_sl.h
===================================================================
--- linux-2.6.23.17.orig/include/linux/netfilter/nf_conntrack_sl.h
+++ linux-2.6.23.17/include/linux/netfilter/nf_conntrack_sl.h
@@ -0,0 +1,75 @@
+#ifndef _NF_CONNTRACK_SL_H
+#define _NF_CONNTRACK_SL_H
+
+#ifdef __KERNEL__
+
+/* enable for module debugging */
+//#define SL_DEBUG 1
+
+// verbose packet debug
+// #define SKB_DEBUG 1
+
+/* packets must be on port 80 to have fun */
+#define SL_PORT 80
+
+/* packets must have this much data to go on the ride */
+#define MIN_PACKET_LEN 256
+
+/* length of SL header
+   X-SLR: 9db44d24|0013102d6976\r\n */
+#define SL_HEADER_LEN 30
+
+/* salt for the hashing */
+#define JHASH_SALT 420
+
+/* maximum packet length */ 
+#define MAX_PACKET_LEN 1480
+
+/* length of the mac address */
+#define MACADDR_SIZE 12
+
+/* max length for host header search */
+#define HOST_SEARCH_LEN 128
+
+static char *ts_algo = "kmp";
+
+enum sl_strings {
+   	HOST,
+	PORT,
+	NEWLINE,
+};
+
+static struct {
+        char                    *string;
+        size_t                  len;
+        struct ts_config        *ts;
+} search[] __read_mostly = {
+        [HOST] = {
+                .string = "\nHost: ",
+                .len    = 7,
+        },
+        [PORT] = {
+                .string = ":8135\r\n",
+                .len    = 7,
+        },
+        [NEWLINE] = {
+                .string = "\n",
+                .len    = 1,
+        },
+};
+
+
+struct nf_conntrack_expect;
+
+extern unsigned int (*nf_nat_sl_hook)(struct sk_buff **pskb,
+                                      enum ip_conntrack_info ctinfo,
+                                      struct nf_conntrack_expect *exp,
+                                      unsigned int host_offset,
+                                      unsigned int data_offset,
+                                      unsigned int datalen,
+				      unsigned char *user_data);
+
+
+#endif /* __KERNEL__ */
+
+#endif /* _NF_CONNTRACK_SL_H */
Index: linux-2.6.23.17/net/ipv4/netfilter/Kconfig
===================================================================
--- linux-2.6.23.17.orig/net/ipv4/netfilter/Kconfig
+++ linux-2.6.23.17/net/ipv4/netfilter/Kconfig
@@ -279,6 +279,10 @@
 	depends on IP_NF_IPTABLES && NF_CONNTRACK && NF_NAT
 	default NF_NAT && NF_CONNTRACK_TFTP
 
+config NF_NAT_SL
+	tristate
+	default m
+
 config NF_NAT_AMANDA
 	tristate
 	depends on IP_NF_IPTABLES && NF_CONNTRACK && NF_NAT
Index: linux-2.6.23.17/net/netfilter/Kconfig
===================================================================
--- linux-2.6.23.17.orig/net/netfilter/Kconfig
+++ linux-2.6.23.17/net/netfilter/Kconfig
@@ -141,6 +141,20 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NF_CONNTRACK_SL
+	tristate "SL protocol support"
+	depends on NF_CONNTRACK
+	help
+	  Tracking SL connections is problematic: special helpers are
+	  required for tracking them, and doing masquerading and other forms
+	  of Network Address Translation on them.
+
+	  This is SL support on Layer 3 independent connection tracking.
+	  Layer 3 independent connection tracking is experimental scheme
+	  which generalize ip_conntrack to support other layer 3 protocols.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config NF_CONNTRACK_H323
 	tristate "H.323 protocol support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && NF_CONNTRACK && (IPV6 || IPV6=n)
