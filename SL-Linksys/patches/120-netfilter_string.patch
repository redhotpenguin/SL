diff -X .ignore -Nru linux.old/Documentation/Configure.help linux.dev/Documentation/Configure.help
--- linux.old/Documentation/Configure.help	2003-11-28 21:26:19.000000000 +0300
+++ linux.dev/Documentation/Configure.help	2007-08-15 14:33:34.000000000 +0400
@@ -2901,6 +2901,14 @@
   If you want to compile it as a module, say M here and read
   <file:Documentation/modules.txt>.  If unsure, say `N'.
 
+String match support (EXPERIMENTAL)
+CONFIG_IP_NF_MATCH_STRING
+  String matching alows you to match packets which contain a
+  specified string of characters.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
 Owner match support
 CONFIG_IP_NF_MATCH_OWNER
   Packet owner matching allows you to match locally-generated packets
diff -X .ignore -Nru linux.old/include/linux/netfilter_ipv4/ipt_string.h linux.dev/include/linux/netfilter_ipv4/ipt_string.h
--- linux.old/include/linux/netfilter_ipv4/ipt_string.h	1970-01-01 03:00:00.000000000 +0300
+++ linux.dev/include/linux/netfilter_ipv4/ipt_string.h	2007-08-15 14:33:49.000000000 +0400
@@ -0,0 +1,23 @@
+#ifndef _IPT_STRING_H
+#define _IPT_STRING_H
+
+/* *** PERFORMANCE TWEAK ***
+ * Packet size and search string threshold,
+ * above which sublinear searches is used. */
+#define IPT_STRING_HAYSTACK_THRESH	100
+#define IPT_STRING_NEEDLE_THRESH	20
+
+#define BM_MAX_NLEN 256
+#define BM_MAX_HLEN 1024
+
+typedef char *(*proc_ipt_search) (char *, char *, int, int);
+
+struct ipt_string_info {
+    char string[BM_MAX_NLEN];
+    char replace_str[BM_MAX_NLEN];
+    u_int16_t invert;
+    u_int16_t len;
+    u_int16_t replace_len;
+};
+
+#endif /* _IPT_STRING_H */
diff -X .ignore -Nru linux.old/net/ipv4/netfilter/Config.in linux.dev/net/ipv4/netfilter/Config.in
--- linux.old/net/ipv4/netfilter/Config.in	2003-08-25 15:44:44.000000000 +0400
+++ linux.dev/net/ipv4/netfilter/Config.in	2007-08-15 14:24:32.000000000 +0400
@@ -42,6 +42,7 @@
   fi
   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
     dep_tristate '  Unclean match support (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_UNCLEAN $CONFIG_IP_NF_IPTABLES
+    dep_tristate '  String match support (EXPERIMENTAL) ' CONFIG_IP_NF_MATCH_STRING $CONFIG_IP_NF_IPTABLES
     dep_tristate '  Owner match support (EXPERIMENTAL)' CONFIG_IP_NF_MATCH_OWNER $CONFIG_IP_NF_IPTABLES
   fi
 # The targets
diff -X .ignore -Nru linux.old/net/ipv4/netfilter/ipt_string.c linux.dev/net/ipv4/netfilter/ipt_string.c
--- linux.old/net/ipv4/netfilter/ipt_string.c	1970-01-01 03:00:00.000000000 +0300
+++ linux.dev/net/ipv4/netfilter/ipt_string.c	2007-08-15 14:55:46.000000000 +0400
@@ -0,0 +1,280 @@
+/* Kernel module to match a string into a packet.
+ *
+ * Copyright (C) 2000 Emmanuel Roger  <winfield@freegates.be>
+ * 
+ * ChangeLog
+ *	22.03.2004: Michael Rash <mbr@cipherdyne.org>
+ *		Added ability to replace a matching string in packet data
+ *		with a new string (checksum automatically recalculated for
+ *		tcp).
+ *	19.02.2002: Gianni Tedesco <gianni@ecsc.co.uk>
+ *		Fixed SMP re-entrancy problem using per-cpu data areas
+ *		for the skip/shift tables.
+ *	02.05.2001: Gianni Tedesco <gianni@ecsc.co.uk>
+ *		Fixed kernel panic, due to overrunning boyer moore string
+ *		tables. Also slightly tweaked heuristic for deciding what
+ * 		search algo to use.
+ * 	27.01.2001: Gianni Tedesco <gianni@ecsc.co.uk>
+ * 		Implemented Boyer Moore Sublinear search algorithm
+ * 		alongside the existing linear search based on memcmp().
+ * 		Also a quick check to decide which method to use on a per
+ * 		packet basis.
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/file.h>
+#include <net/sock.h>
+#include <net/tcp.h>
+#include <net/udp.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_string.h>
+
+MODULE_LICENSE("GPL");
+
+struct string_per_cpu {
+	int *skip;
+	int *shift;
+	int *len;
+};
+
+struct string_per_cpu *bm_string_data=NULL;
+
+/* Boyer Moore Sublinear string search - VERY FAST */
+char *search_sublinear (char *needle, char *haystack, int needle_len, int haystack_len) 
+{
+	int M1, right_end, sk, sh;  
+	int ended, j, i;
+
+	int *skip, *shift, *len;
+	
+	/* use data suitable for this CPU */
+	shift=bm_string_data[smp_processor_id()].shift;
+	skip=bm_string_data[smp_processor_id()].skip;
+	len=bm_string_data[smp_processor_id()].len;
+	
+	/* Setup skip/shift tables */
+	M1 = right_end = needle_len-1;
+	for (i = 0; i < BM_MAX_HLEN; i++) skip[i] = needle_len;  
+	for (i = 0; (int) needle[i]; i++) skip[(int) needle[i]] = M1 - i;  
+
+	for (i = 1; i < needle_len; i++) {   
+		for (j = 0; j < needle_len && needle[M1 - j] == needle[M1 - i - j]; j++);  
+		len[i] = j;  
+	}  
+
+	shift[0] = 1;  
+	for (i = 1; i < needle_len; i++) shift[i] = needle_len;  
+	for (i = M1; i > 0; i--) shift[len[i]] = i;  
+	ended = 0;  
+	
+	for (i = 0; i < needle_len; i++) {  
+		if (len[i] == M1 - i) ended = i;  
+		if (ended) shift[i] = ended;  
+	}  
+
+	/* Do the search*/  
+	while (right_end < haystack_len)
+	{
+		for (i = 0; i < needle_len && haystack[right_end - i] == needle[M1 - i]; i++);  
+		if (i == needle_len) {
+			return haystack+(right_end - M1);
+		}
+		
+		sk = skip[(int) haystack[right_end - i]];  
+		sh = shift[i];
+		right_end = max(right_end - i + sk, right_end + sh);  
+	}
+
+	return NULL;
+}  
+
+/* Linear string search based on memcmp() */
+char *search_linear (char *needle, char *haystack, int needle_len, int haystack_len) 
+{
+	char *k = haystack + (haystack_len-needle_len);
+	char *t = haystack;
+	
+	while ( t <= k ) {
+		if (memcmp(t, needle, needle_len) == 0)
+			return t;
+		t++;
+	}
+
+	return NULL;
+}
+
+
+static int
+match(const struct sk_buff *skb,
+      const struct net_device *in,
+      const struct net_device *out,
+      const void *matchinfo,
+      int offset,
+      const void *hdr,
+      u_int16_t datalen,
+      int *hotdrop)
+{
+	const struct ipt_string_info *info = matchinfo;
+	struct iphdr *ip = skb->nh.iph;
+	struct tcphdr *tcph;
+	/* struct udphdr *udph; */
+	int hlen, nlen, rlen, rctr;
+	char *needle, *haystack, *repl_str, *repl_ptr;
+	proc_ipt_search search=search_linear;
+
+	if ( !ip ) return 0;
+ 
+	/* get lengths, and validate them */
+	nlen=info->len;
+	rlen=info->replace_len;
+	hlen=ntohs(ip->tot_len)-(ip->ihl*4);
+	if ( nlen > hlen ) return 0;
+
+	/* if we are altering packet data, make absolutely sure
+	 * replace length is less than or equal to needle length.
+	 * We cannot start breaking protocols! */
+	if ( rlen > 0 && rlen > nlen ) return 0;
+
+	needle=(char *)&info->string;
+	repl_str=(char *)&info->replace_str;
+	haystack=(char *)ip+(ip->ihl*4);
+
+	/* The sublinear search comes in to its own
+	 * on the larger packets */
+	if ( (hlen>IPT_STRING_HAYSTACK_THRESH) &&
+	  	(nlen>IPT_STRING_NEEDLE_THRESH) ) {
+		if ( hlen < BM_MAX_HLEN ) {
+			search=search_sublinear;
+		}else{
+			if (net_ratelimit())
+				printk(KERN_INFO "ipt_string: Packet too big "
+					"to attempt sublinear string search "
+					"(%d bytes)\n", hlen );
+		}
+	}
+	
+	repl_ptr = search(needle, haystack, nlen, hlen);
+
+	if (repl_ptr != NULL && rlen > 0) {
+		/* if we change the data portion of the packet we recalculate
+		 * the transport layer checksum (mandatory for TCP). */
+		if (skb->nh.iph->protocol == IPPROTO_TCP) {
+			int offset, rest_len;
+			int diff = nlen - rlen;
+			/* char *end = (char *)(skb->nh.iph + htons(ntohs(ip->tot_len))); */
+			unsigned int tcplen = skb->len - (skb->nh.iph->ihl<<2) - diff;
+			/* repl_ptr points to the start of the needle
+			 * in the packet, and we know the entire needle
+			 * is there so we can just replace. */
+			for (rctr=0; rctr < rlen; rctr++)
+				repl_ptr[rctr] = repl_str[rctr];
+
+			rest_len = ((char *)skb->tail - repl_ptr) - nlen;
+			offset = (unsigned char *)&repl_ptr[nlen] - skb->data;
+			if (skb_copy_bits(skb, offset, repl_ptr, rest_len))
+				return 0;
+           if (___pskb_trim(skb, skb->len-diff, 1)) return 0; //skb->len = skb->len - diff;
+			skb->nh.iph->tot_len = ntohs(ip->tot_len) - diff;
+			ip_fast_csum((unsigned char *)skb->nh.iph, skb->nh.iph->ihl);
+
+			tcph = (struct tcphdr *)((u_int32_t*)skb->nh.iph + skb->nh.iph->ihl);
+			tcph->check = 0;
+			tcph->check = tcp_v4_check(tcph, tcplen, skb->nh.iph->saddr,
+							skb->nh.iph->daddr,
+							csum_partial((char *)tcph, tcplen, 0));
+		} /* else if (skb->nh.iph->protocol == IPHPROTO_UDP) { */
+			/* repl_ptr points to the start of the needle
+			 * in the packet, and we know the entire needle
+			 * is there so we can just replace. */
+			/* for (rctr=0; rctr < rlen; rctr++)
+				repl_ptr[rctr] = repl_str[rctr]; */
+			/* recalculate UDP checksum only if it was previously
+			 * calculated */
+		/*	udph = (struct udphdr *)((char *)skb->nh.iph + (skb->nh.iph->ihl<<2));
+			unsigned int udplen = skb->len - (skb->nh.iph->ihl<<2);
+			if (udph->check) {
+				udph->check = 0;
+				udph->check = csum_tcpudp_magic(skb->nh.iph->saddr,
+								skb->nh.iph->daddr,
+								udplen, IPPROTO_UDP,
+								csum_partial((char *)udph, udplen, 0));
+			}
+		}*/
+	}
+    return ((repl_ptr!=NULL) ^ info->invert);
+}
+
+static int
+checkentry(const char *tablename,
+           const struct ipt_ip *ip,
+           void *matchinfo,
+           unsigned int matchsize,
+           unsigned int hook_mask)
+{
+
+       if (matchsize != IPT_ALIGN(sizeof(struct ipt_string_info)))
+               return 0;
+
+       return 1;
+}
+
+void string_freeup_data(void)
+{
+	int c;
+	
+	if ( bm_string_data ) {
+		for(c=0; c<smp_num_cpus; c++) {
+			if ( bm_string_data[c].shift ) kfree(bm_string_data[c].shift);
+			if ( bm_string_data[c].skip ) kfree(bm_string_data[c].skip);
+			if ( bm_string_data[c].len ) kfree(bm_string_data[c].len);
+		}
+		kfree(bm_string_data);
+	}
+}
+
+static struct ipt_match string_match
+= { { NULL, NULL }, "string", &match, &checkentry, NULL, THIS_MODULE };
+
+static int __init init(void)
+{
+	int c;
+	size_t tlen;
+	size_t alen;
+
+	tlen=sizeof(struct string_per_cpu)*smp_num_cpus;
+	alen=sizeof(int)*BM_MAX_HLEN;
+	
+	/* allocate array of structures */
+	if ( !(bm_string_data=kmalloc(tlen,GFP_KERNEL)) ) {
+		return 0;
+	}
+	
+	memset(bm_string_data, 0, tlen);
+	
+	/* allocate our skip/shift tables */
+	for(c=0; c<smp_num_cpus; c++) {
+		if ( !(bm_string_data[c].shift=kmalloc(alen, GFP_KERNEL)) )
+			goto alloc_fail;
+		if ( !(bm_string_data[c].skip=kmalloc(alen, GFP_KERNEL)) )
+			goto alloc_fail;
+		if ( !(bm_string_data[c].len=kmalloc(alen, GFP_KERNEL)) )
+			goto alloc_fail;
+	}
+	
+	return ipt_register_match(&string_match);
+
+alloc_fail:
+	string_freeup_data();
+	return 0;
+}
+
+static void __exit fini(void)
+{
+	ipt_unregister_match(&string_match);
+	string_freeup_data();
+}
+
+module_init(init);
+module_exit(fini);
diff -X .ignore -Nru linux.old/net/ipv4/netfilter/Makefile linux.dev/net/ipv4/netfilter/Makefile
--- linux.old/net/ipv4/netfilter/Makefile	2003-08-25 15:44:44.000000000 +0400
+++ linux.dev/net/ipv4/netfilter/Makefile	2007-08-15 14:24:32.000000000 +0400
@@ -86,6 +85,7 @@
 obj-$(CONFIG_IP_NF_MATCH_STATE) += ipt_state.o
 obj-$(CONFIG_IP_NF_MATCH_CONNTRACK) += ipt_conntrack.o
 obj-$(CONFIG_IP_NF_MATCH_UNCLEAN) += ipt_unclean.o
+obj-$(CONFIG_IP_NF_MATCH_STRING) += ipt_string.o
 obj-$(CONFIG_IP_NF_MATCH_TCPMSS) += ipt_tcpmss.o
 
 # targets

