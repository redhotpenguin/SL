#!/bin/env perl
use strict;
use warnings;

=head1 NAME

sl_fw_ha - pings a set of sl proxies to maintain high availability

=head1 SYNOPSIS

Run this script from cron, frequently:

  */30 * * * * sl_fw_ha

=head1 DESCRIPTION

This script pings a set of SL proxies, and restarts the firewall if the proxy
isn't responding.

=cut

use Cache::FastMmap;
use LWP::UserAgent;
use Data::Dumper;

our $DEBUG         = 0;
our $LAN           = 'br0';
our $SL_PROXY_FILE = '/usr/local/sl/conf/proxy_list.txt';

our $IPTABLES_SAVE_FILE;
if ( -e '/etc/sysconfig/iptables' ) {
    $IPTABLES_SAVE_FILE = '/etc/sysconfig/iptables';
} elsif ( -e '/var/lib/iptables/rules-save' ) {
	$IPTABLES_SAVE_FILE = '/var/lib/iptables/rules-save';
} else {
	print STDERR "No file to save iptables rule could be found, exiting\n";
	exit(1);
}

our $IPTABLES = '/sbin/iptables';
our $IPTABLES_SAVE = '/sbin/iptables-save';
unless (-e $IPTABLES) {
	print STDERR "No iptables executable at $IPTABLES\n";
	exit(1);
}
unless (-e $IPTABLES_SAVE) {
	print STDERR "No iptables-save executable at $IPTABLES_SAVE\n";
	exit(1);
}

# load the cache-file used by the trans-handler
my $cache = Cache::FastMmap->new(
    raw_values => 1,
	share_file => "/tmp/sl_config_cache",
    cache_size => '16m',
);

# get list of possible proxies
unless (-e $SL_PROXY_FILE) {
    print STDERR "No proxy config file $SL_PROXY_FILE\n";
	mark_proxy_down();
    exit(0);
}

my ( $fh, @proxies );
open( $fh, "<", $SL_PROXY_FILE ) or die "file error: $SL_PROXY_FILE, $!";
while (<$fh>) {
    chomp($_);
    push @proxies, $_;
}

# grab a random proxy and make it the current proxy
my $current_proxy = $proxies[ int( rand( scalar(@proxies) ) ) ];

print STDERR "Current proxy: $current_proxy \n" if $DEBUG;

my $ua  = LWP::UserAgent->new;
my $url = 'http://' . $current_proxy . '/sl_secret_ping_button';

print STDERR "Checking $current_proxy...\n" if $DEBUG;
my $response = $ua->get($url);
if ( $response->code == 200 ) {
    print STDERR "Got 200 response, current proxy is open.\n" if $DEBUG;
    if ( $cache->get('proxy_down') ) {
        print STDERR "RECOVERY - Proxy marked down last time, restarting\n";
        # turn sl back on
        my $iptables = <<IPTABLES;
-F
-t nat -F
-t nat -A PREROUTING -i $LAN -p tcp --dport 80 --dst ! 192.168.0.0/16 -j DNAT --to $current_proxy
IPTABLES
        my @cmds = split("\n", $iptables);
        foreach my $cmd (@cmds) {
            system("$IPTABLES $cmd") == 0
                or die "error updating firewall: $!";
        }
        system("$IPTABLES_SAVE > $IPTABLES_SAVE_FILE") == 0
            or die "error updating firewall: $!";
        $cache->set( 'proxy_down' => 0 );
        exit(0);
    }
} else {
    print STDERR "ERROR - Got " . $response->code . " response, proxy is down.\n";
	print STDERR "Reponse content: " . Dumper($response->content) . "\n";
    mark_proxy_down();

	exit(0);
}

sub mark_proxy_down {
    # create a new iptables ruleset
    my $iptables = <<IPTABLES;
-F
-t nat -F
IPTABLES
    my @cmds = split("\n", $iptables);
    foreach my $cmd (@cmds) {
            system("$IPTABLES $cmd") == 0
                or die "error updating firewall: $!";
    }
    system("$IPTABLES_SAVE > $IPTABLES_SAVE_FILE") == 0
        or die "error updating firewall: $!";
 
    $cache->set( 'proxy_down' => 1 );
}

1;
